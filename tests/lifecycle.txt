================================
Simple project lifecycle support
================================

Summary
=======
The project lifecycle commands allow for creating a set of maintenance
branches on every checkout in a build tree.

Let us assume that we have a build tree with build name "Widget", and that
release version 1.0 of the Widget product has just been delivered. We want to
continue working towards version 2 of the product in the "normal" build tree,
but we may also need to make maintenance releases based on version 1.0 of the
code.

Muddle allows us to branch all of the checkouts in the build tree, so that we
can do the v1.0 maintenance work on its own branch. Thus::

  $ muddle branch-tree Widget-v1.0-maintenance

will perform various checks, and then create a new branch called
``Widget-v1.0-maintenance`` in each checkout.

.. note:: It is worth naming maintenance branches carefully so that they are
   unlikely to clash with any existing branchs in any of the checkouts. Using
   the build name, the version number, and some additional descriptive text
   (here, just "maintenance") seems sensible.

We then need to tell the (branched) build description that all its checkouts
should "follow" its branch (we'll see why furhter below). So we add the line::

  $ builder.follow_build_desc_branch = True

to the build description (normally in ``src/builds/01.py``).

We now need to commit and push all of these changes. Unfortunately, we don't
yet have a way of doing a "muddle commit" that specifies a commit message, so
the best we can do (assuming everything is using git) is::

  $ muddle runin _all_checkouts 'git commit -a -m "Create maintenance branch"'

and then::

  $ muddle push _all

Since the checkouts are on the branch requested by the build description
(because we set the "follow" flag), this will push the new branch to the
remote repositories, even though it didn't exist before.

At which stage, our remotes all have the branch, and our checkouts are still
on it. That's probably a good time to record a stamp file::

  $ muddle stamp version

Branching the build tree doesn't branch the "versions/" directory, but because
we have set "follow" in the build description, the stamp file created will be
called::

  versions/<build_name>.<branch_name>.stamp

instead of the normal ``versions/<build_name>.stamp``.

We can now change to a new, empty directory, and make a new copy of our
maintenance build tree::

  $ cd ..
  $ mkdir Widget-v1.0-maintenance
  $ cd Widget-v1.0-maintenance

  $ muddle init -branch Widget-v1.0-maintenance <repo> builds/01.py

(where ``<repo>`` is the remote repository).

This gets the build description on the named branch. If we look in the
``.muddle/`` directory, we can see that there is a new file::

  .muddled/DescriptionBranch

which contains the name of the branch used at "muddle init" (it will only be
present if "-branch" was used, and it is never altered by muddle itself).

We can now do::

  $ muddle checkout _all

and, because the build description has "follow_build_desc_branch" set, all
the checkouts will also be checked out with that branch.

You can use::

  $ muddle query checkout-branches

to see the details of the branches being used, and why. For instance::

  $ m3 query checkout-branches
  --------  -----------------------  -----------------------  -----------------------
  Checkout  Current branch           Original branch          Branch to follow       
  --------  -----------------------  -----------------------  -----------------------
  builds    Widget-v0.1-maintenance  Widget-v0.1-maintenance  <it's own>             
  co1       Widget-v0.1-maintenance  master                   Widget-v0.1-maintenance

"Original branch" is the branch as requested by the build description.
Normally that will be "master" - i.e., the default branch - but sometimes a
build description specifies a particular branch for a checkout.

If a build description *does* specify a particular branch (or revision) for a
checkout, or if a checkout is not using git, then ``muddle branch-tree`` will
not be able to branch it for you, and you will have to decide what to do about
that checkout in this context, a maintenance tree.


Commands
========

New or changed (I think)::

  muddle init -branch <branch> <repo> <build>

  muddle query build-desc-branch

  muddle query checkout-id

  muddle query checkout-vcs

  muddle query checkout-branches

  muddle branch-tree ...

  muddle sync



What is this about?
===================
Let us assume that we have been developing a build tree, and we reach the
point of releasing version 1 of the product that it builds. We can do the
normal steps of generating stamp files (``muddle stamp``), perhaps producing
source releases (``muddle distribute``), and quite likely producing an actual
release tarball (``muddle release``), but then we want to continue development
towards the next version of the product.

The problem is that we almost certainly also want to be able to go back and
produce later "bugfix" releases based on version 1, and ideally we would like
muddle to make this easy for us.

One rather cumbersome way to do this would be make a branch of our build
description describing, explicitly, what is in release 1. So we could look at
the stamp file we produced for our release (of course we made a stamp file),
and for each checkout, explicitly specify its revision in the build
description. If we committed that (on its branch), then we could later build
our tree again, making sure we're using the branch of the build description.
If we needed to fix a bug in a particular package, we could then branch that
package, determine the new revision, update the build description, and so on.

This would be extremely tedious, and definitely error prone.

A slightly (but only slightly) better approach would still specify all of the
revisions "by hand", but when a package was changed for a bugfix, we would
perofrm the change on an appropriate branch, and amend the build description
for that package to specify this new branch instead of the revision.

Which is really not that much better.

So instead we provide a mechanism to branch all checkouts in a build tree,
and to use the same branch (i.e., branch name) for the build description and
the checkouts.

.. note:: This assumes that all the checkouts support this mechanism. At time
   of writing, muddle supports this for git. If most checkouts use git, and a
   few use a VCS that is not supported for this purpose, then one of the
   "solutions" above may be adopted for the less able VCS checkouts.

How we do it
============
This means we would:

1. Decide we're going to make release 1. If our build is called
   "Widget", we might thus decide to use a branch called
   "Widget-v1.0-maintenance".

     (It seems sensible to put the name of our build tree into the branch
     name as a way of avoiding clashes with any previous branches in the
     individual checkouts. It is quite likely that some checkout of source
     code from elsewhere might have already have a branch called "v1.0", for
     instance. Whilst muddle can warn if this is the case, it is ultimately
     up to the user to choose an appropriate branch name.)

2. We then use::

      $ muddle branch-tree Widget-v1.0-maintenance

   to make various checks, and then branch all the checkouts.

3. We then edit the build description (which is now on the new branch) and
   add a line to the ``describe_to()`` function::

      builder.follow_build_desc_branch = True

   This tells muddle that checkouts should use the same branch as the build
   description. Of course, if the build description explicitly specifies a
   revision or branch for a checkout, then that takes precedence, so please
   remember to check.

   A build description with this value set is described as having set
   "following", and the build tree "follows" the build description.

   .. note:: Muddle tries to be a little bit helpful by also recognising
      the (mistaken)::

        builder.follows_build_desc_branch = True

      and treating that as an error - otherwise the nature of Python
      would allow this, with no effect.

4. We then need to commit everything. We really need a::

     $ muddle commit _all -m <message>

   but we don't have one yet, but we can do::

     $ muddle runin _all_checkouts 'git commit -a -m "Create maintenance branch"'

   if we are careful with the quoting.

5. We can then do::

     $ muddle push _all

   to push the build description and all the branched checkouts.

6. As one might expect, it's then generally a good idea to take a stamp::

     $ muddle stamp version

   Since our build description sets "following", the version stamp file
   will be called::

     versions/<build-name>.<build-desc-branch>.stamp

   The "versions/" directory is *not* branched by ``muddle branch-tree``,
   since it is meant to contain all the version stamps for the project.
   Thus naming the stamp file with the branch name (which should indicate
   the purpose of the branch) is a sensible solution.

If anyone does a ``muddle init`` of the build tree, they will still get the
normal ("master") branch, which we have not altered, and can ``muddle
checkout`` and continue mainstream development just as normal.

However, if we want to do a bugfix on version 1, we can do::

  $ muddle init -b Widget-v1.0-maintenance <repo> src/builds
  $ muddle checkout _all

where ``<repo>`` is the same repository spec as used in the original
``muddle init`` (and remembered in ``.muddle.RootRepository``).

This will checkout the build description on the named branch, and then,
because the build description sets "follow", will checkout the same branch
of each checkout.

We can use::

  $ muddle query checkout-branches

to show that the correct branches are checked out (see ``muddle help query
checkout-branches`` for what the columns output by that command mean).

We can also use ``muddle query build-desc-branch`` to see if we are
"following"::

  $ muddle query build-desc-branch
  Build description checkout:builds/* is on branch Widget-v1.0-maintenance
    This WILL be used as the default branch for other checkouts

One last useful command, introduced as part of the support for branched
builds, is ``muddle sync``. This is used to put the branch of a checkout
(or checkouts) back to what the build description says it should be.
This can be useful if you've been switching branches to look at alternative
implementations of a checkout. How it actually decides what to do is slightly
complex - see ``muddle help sync`` for details.

Details of how ``muddle push`` and other commands work
======================================================

... the various muddle help commands

... forcing use of an existing branch (and why one might do that)

... ``muddle push``

... ``muddle pull``

... ``muddle merge``

... ``muddle reparent``

How do I tell a checkout to go (back) to the branch implicitly specified by
this mechanism?

... an example of a build with git and bzr checkouts in it, and how to cope
(as mentioned in the introduction)

Muddle commands in branched build trees
=======================================
In the following, I'm assuming that the build description sets "following",
and is on a branch, and that the checkouts being discussed are using git
(because muddle doesn't support branching in other version control systems).

In a branched build tree, the build description sets "following". A checkouts
branch is determined as follows:

  1. If a specific revision and a specific branch are specified in the build
     description, then muddle "goes to" that branch and then, if necessary
     changes to the specified revision. If the revision is not HEAD of the
     branch, this will leave the checkout on a detached HEAD (see
     http://alblue.bandlem.com/2011/08/git-tip-of-week-detached-heads.html
     for a useful explanation of this).

  2. If a specific revision alone is given in the build description, then that
     will be used. This will result in a detached HEAD.

  3. If a specific branch alone is given in the build description, then that
     branch will be used.

  4. Otherwise, the build description branch will be used.

.. note:: This is identical to how things normally work, except that in a
   non-"follow" build tree, step 4 chooses "master" instead of the build
   description branch.

There is one caveat: if the version control system being used for the checkout
is not one that muddle knows how to branch (i.e., at the moment, is not git),
then revisions are followed, but branches are not.

You can use ``muddle query checkout-branches`` or read the build description
to see what applies for each checkout.

So, looking at specific commands, and remembering these descriptions are for
checkouts using git:

* ``muddle checkout`` will clone the appropriate branch of the checkout, as
  described above.

* ``muddle pull`` and ``muddle merge`` will first go to the appropriate
  branch, and then do their work.

* ``muddle push`` will push the current branch of the checkout, creating that
  branch at the far end if necessary. It does not check if this is the
  "appropriate" branch or not.

* ``muddle pull-upstream`` and ``muddle push-upstream`` both act as their
  "normal" versions, but pull from or push to the nominated remote(s).

* ``muddle sync`` sets the checkout to the "appropriate" branch. ``muddle sync
  -verbose`` tells you how it is deciding this, and ``muddle sync -show``
  tells you but doesn't actually do it. These can be useful when trying to
  decide why one is not on the branch one expected. 

* ``muddle stamp version`` will use a stamp name that incorporates the build
  description branch name.

* ``muddle stamp release`` does not itself know about branched trees. However,
  the user should take care to specify a sensible version number for the
  release stamp when creating it. The ``-next`` switch is unlikely to be
  useful in this case.

What happens if there are sub-domains?
======================================
Branched trees are not yet fully supported for subdomains.

It is possible to do ``muddle branch-tree`` with subdomains, and the
subdomains checkouts will be branched as appropriate.

Setting the "follow" flag is only supported for the top-level build
description - the value of ``builder.follow_build_desc_branch`` in subdomain
build descriptions is ignored. This is the simplest possible useful decision -
i.e., that all of the tree is branched for the same version - and is one of
the reasons it is important to choose a good name for the branch.

Restoring a branched tree using a version stamp should work, but doing
``muddle init -branch`` on a build containing subdomains will not, at time of
writing, actually branch the subdomains, so one would have to do::

  $ muddle init -branch Widget-v1.0-maintenance <repo> builds/01.py
  $ muddle checkout _all
  $ muddle sync _all

which should work (but is not tested), or, more precisely::

  $ muddle init -branch Widget-v1.0-maintenance <repo> builds/01.py
  $ muddle sync <subdomain-build1> <subdomain-build2> ...
  $ muddle checkout _all

This is unsatisfactory, as inclusion of subdomains is meant to be transparent.

Probably, muddle should do that 'sync' for you...

What happens with upstream repositories?
========================================
A local repository can be linked to several upstream repositories. Checkouts
that use that local repository can then do push-upstream and/or pull-upstream
commands to those upstreams.

The local repository used is always as described in the build description.
So if the build description describes upstream repositories for local
repository R, and checkout C uses repository R (as described in the build
description), it can do upstream operations "through" R.

If checkout C is "following" the build description, and the build description
is on branch <branch>, then normal muddle checkout operations will take
account of branch <branch>, and so C will interact with branch <branch> of R.
However, the upstream operations continue to relate C directly to R, and so
the upstreams are found in the same way as a "normal" build.

However, there are some caveats.

Doing an


Upstream repositories are remembered using a dictionary that is keyed by the
"normal" Repository for a checkout, and holds the upstream Repository
instances as the value for that key.

Now, at the moment, the checkout repository is used directly as the key.
This should be the same Repository object as in db.checkout_repositories.

But when we make our checkout follow the build description branch, we want to
change the .branch in the Repository (so the VCS stuff will "just work").

Which will also *maybe* change the .branch in the Repository being used as a
key, above. Which may or may not be what we want.

I suspect not, as we don't know that the branch here maps to an upstream
branch. In which case, add_upstream_repository should *probably* be taking a
copy of each Repository (probably both keys and values) before inserting them
into its dictionary.

Does this apply elsewhere as well?

...Probably want to add a .copy() method to Repository, to save using
copy.deepcopy() explicitly ourselves.


.. vim: set filetype=rst tabstop=8 softtabstop=2 shiftwidth=2 expandtab:
