#! /usr/bin/env python
#
# -*- mode: python -*-
#

"""
Main program for muddle

muddle <[options]> command <[args]>

Options include:

  --help, -h, -?      This help text
  --tree [dir]        Use the muddle build tree at [dir]

If you don't give --tree, we'll traverse directories up to the root
to try and find a .muddle directory which signifies the top of the
build tree.

"""

import sys
import muddled
import os
import traceback


def usage():
    """
    Return the usage message
    """
    
    result_array = [ __doc__ ]
    cmd_dict = muddled.register_commands()
    result_array.append("Commands: \n")
    result_array.append("\n")
    keys = cmd_dict.keys()
    keys.sort()

    for k in keys:
        v = cmd_dict[k]
        result_array.append(k)
        result_array.append("\n")
        result_array.append(v.help())
        result_array.append("\n\n")
        
    return "".join(result_array)


def main(args):
    """
    Main program
    """

    specified_root = os.getcwd()
    command = None
    muddle_binary = __file__


    # Command dictionary. Maps command name to a tuple
    # (Boolean, command_fn)
    #
    # The boolean tells us whether this command requires an
    # initialised build tree or not (init obviously doesn't ..)
    #
    # Every command gets:
    #
    #  (invocation, local_package_list)

    while args:
        word = args[0]
        if word in ('-h', '--help', '-?'):
            print usage()
            return
        elif word == '--tree':
            args = args[1:]
            build_root = args[0]
        elif word[0] == '-':
            raise muddled.Error, "Unexpected command line option %s"%word
        else:
            break

        args = args[1:]


    if len(args) < 1:
        # The command is implicitly 'build' with the default label, or
        # _all if none was specified.
        command_name = "build"
        with_default_args = True
    else:
        command_name = args[0]
        args = args[1:]
        with_default_args = False

    current_dir = os.getcwd()

    # The help command needs to be provided here because the 
    # command module doesn't have the necessary information
    if (command_name == "help"):
        print usage()
        sys.exit(0)

    # First things first, let's look up the command .. 
    cmd_dict = muddled.register_commands()
    
    if (command_name not in cmd_dict):
        raise muddled.Error("No such command: %s"%command_name)

    command = cmd_dict[command_name]
    failed_build_root = False

    try:
        try:
            build_root = muddled.utils.find_root(specified_root)
            if (build_root is not None):
                builder = muddled.mechanics.load_builder(build_root, muddle_binary)
            else:
                builder = None    
        except muddled.utils.Failure as f:
            print "%s"%f
            build_root = None
            failed_build_root = True
        except muddled.utils.Error as e:
            print "Cannot find build tree - %s"%e
            traceback.print_exc()
            build_root = None
            failed_build_root = True
        
        
        if (build_root is None):
            # There is no build root here .. 
            if with_default_args and not (failed_build_root):
                # Guess that you wanted help.
                print usage()
                sys.exit(0)

            if (not command.requires_build_tree()):
                return command.without_build_tree(muddle_binary, specified_root, args)
            else:
                if not failed_build_root:
                    raise muddled.Failure("Command %s requires a build tree."%(command_name))

        else:
            # There is a build tree...
            # Let's find the list of local packages .. 
            local_pkgs = muddled.utils.find_local_packages(current_dir, build_root, 
                                                           builder.invocation)

            if with_default_args:
                # Where are we?
                (what, loc, role) = muddled.utils.find_location_in_tree(current_dir, build_root)
                if (what == muddled.utils.DirType.Root):
                    # We're at the root.
                    command = cmd_dict["buildlabel"]
                    args = map(str, builder.invocation.default_labels)
        
            return command.with_build_tree(builder, local_pkgs, args)

    except muddled.utils.Failure as f:
        print "%s"%f
        sys.exit(1)

if __name__ == "__main__":
    try:
        rv = main(sys.argv[1:])
        sys.exit(rv)
    except muddled.Error, why:
        print "%s"%why
        sys.exit(1)


# End file.
