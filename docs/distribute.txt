=================================================
Distributions, licenses and ``muddle distribute``
=================================================

What we want to do
==================
We want to be able to:

* Distribute build trees to other users, without their needing to clone
  stuff from the build's repositories.

* Indicate the licensing for checkouts, and thus

* Distribute partial build trees, especially partial build trees whose content
  is determined by that licensing.

* In particular, distribute partial build trees that satisfy GPL compliance
  rules, but are still maximally useful *as* build trees.

The ``muddle distribute`` command
=================================
The ``muddle distribute`` command is intended to help with the following use
cases:

1. I want to distribute all of my source code as an archive (typically, a
   ``.tgz`` (gzipped TAR file) or ``.zip`` file). How do I extract the
   relevant directories?

2. I want to prepare a binary release for passing to someone.

3. I want to prepare a distribution where some packages are distributed as
   source code, some as binary, and some not at all. This should be doable
   by:

   a. specifying checkouts and packages explicitly, or
   b. specifying checkout licenses, and selecting based on licenses.

That third case was actually the driving force of the development of muddle
distribution support, as we wanted to be able to produce a build tree
containing source code for any open-source packages, binary blobs for
proprietary packages whose source code is private, and omitting
entirely packages that are "private" (i.e., typilcally for proprietary
reasons).

The desired intent is that, whatever means (1 through 3) is used, the result
should be a functioning muddle build tree. Clearly this might not always be
possible for some of the more extreme values of case 3 (if too much of the
build tree is not distributed because it is "private"), but even in such cases
it should ideally be possible to write the build description(s) in such a
manner that something useful can be built.

  (For instance, GPL v2 says "For an executable work, complete source code
  means all the source code for all modules it contains, plus any associated
  interface definition files, plus the scripts used to control compilation and
  installation of the executable." (I hope that counts as fair quoting!).
  At the individual checkout/package level, the Makefiles are simple to
  distribute. Quite often the "scripts used to ..." for the entire system,
  though, are indeed those used to build the system, but don't actually
  function outside the original context in which they were used. We'd like to
  make it possible, in this sort of situation, to distribute muddle build
  trees that actually work and produce someting
  useful.)

What is a distribution?
=======================
A distribution is two things:

1. a copy of all or part of the muddle build tree (the result of distributing)
2. a description of what to copy, for this purpose

The ``muddle distribute`` command uses an instance of (2) to produce (1).

Distributions are identified by a name, and which license categories they may
take as "input".

The name is just a string. As normal, we reserve names starting with
underscore (``_``) for muddle itself to define. These are termed "standard
distributions", and new standard distributions may be introduced as time goes
on, so avoid defining new distributions with names starting with an
underscore.  

Standard distributions include:

* ``_source_release`` - discussed in `Case 1: Source distribution`
* ``_binary_release`` - discussed in `Case 2: Binary distribution`
* ``_for_gpl`` - discussed in `Case 3: The other standard distributions`
* ``_all_open`` - ditto
* ``_by_license`` - ditto

License categories are the board classification of license type, and are
discussed below.

How does it work?
=================
.. note:: Ignore this little section if you want.

More-or-less as you might expect, with labels and tags and actions.

Basically, for those checkouts or packages that are to be distributed, a rule
is added to "build" label ``checkout:<name>/distributed`` from
``checkout:<name>/checked_out`` using the DistributeCheckout action, or
``package:<name>{<role>)/distributed`` from
``package:<name>{<role>}/postinstalled`` using the DistributePackage action.

.. note:: *Technically* doing a DistributePackage of just the ``obj``
   directories doesn't require that the package(s) be ``/postinstalled``,
   as ``/built`` would suffice. I don't think that's worth worrying about
   at the moment, especially as ``muddle`` always builds through to
   ``/postinstalled`` if at all posible (i.e., that's what ``muddle build``
   does, and see what it says in ``muddle help build`` about depending
   on ``/postinstalled`` being the norm).

For source and binary releases (cases 1 and 2) the ``muddle distribute``
command itself organises this. For case 3, appropriate code in the build
description causes the rules to be added, or sets the conditions that allow
``muddle distribute`` to do it.

You won't, however, see any ``/distribute`` tags in the ``.muddle`` tags
directories, as the ``/distribute`` tag is treated as "transient" - i.e., it
doesn't get recorded on disk. This avoids problems if one (for instance) does
a source distribution with VCS to one directory, and then without to another,
followed by a partial distribution to yet another - it would not be clear what
the ``/distribute`` tags meant, and it would always be necessary to clear them
before each ``muddle distribute``.

Source distribution
===================
In a simple build tree, where there are no subdomains, a `.tgz`` file can be
produced with a command like::

  $ tar -zcvf archive.tgz build/src build/.muddle build/versions

where ``build`` is the directory containing the build tree.

If VCS directories (``.git/`` and the like) are not wanted, then something
like::

  $ tar -zcvf --exclude-vcs archive.tgz build/src build/.muddle build/versions

may suffice.

However:

a. Neither of those copies over the ``.muddle`` directory, and if one asked
   to archive the ``.muddle`` directory, one would get all of it, not just
   the parts needed (and one might also get tags set for packages indicating
   that they have been built, which will not be true of the archived build
   tree).
b. If there are subdomains, the command would need to be rather more complex.
   And if you're doing something weird, like having a VCS directory (perhaps
   ``.git``) for the tree as stored in the local repositories, but also a
   historitcal VCS directory (perhaps ``.bzr``) that came with the checkout
   when it was imported, then it all gets rather difficult.

So instead the standard distribution "_source_release" is provided. The
command::

  $ pushd build
  $ muddle distribute -with-version _source_release ../release_1.0
  $ popd
  $ tar -zcvf release_1.0.tgz release_1.0

which will copy the sources to a directory called ``release_1.0``.

Specifically, it will copy:

* each checkout directory, including the build description, in all domains
* the ``versions`` directory, if it exists
* the necessary parts of the ``.muddle`` directory:

  * the ``Description``,  ``RootRepository`` and ``VersionsRepository`` files
  * the ``tags/checkout`` directory and the tags for the copied checkouts

It does not copy VCS "special" files (as determined by the build description,
``.git``, ``.gitignore``, etc.) for the checkouts, or for the ``versions``
directory.

If the ``versions`` directory is not wanted, then the ``-with-versions``
switch can be left off.

If the VCS "special" files in the checkouts (and ``versions`` directory) *are*
wanted, then the ``-with-vcs`` switch should be specified::

  $ muddle distribute -with-version -with-vcs _source_release ../release_1.0.vcs

In either case, because the necessary parts of the ``.muddle`` directory have
been copied, it should be possible to build the build tree in the normal
manner::

  $ cd release_1.0
  $ muddle

Binary distribution
===================
Sometimes someone wants a binary release. A binary release is taken to be
the "end product" of doing a ``muddle build``, and is thus the content of the
``install`` directories, plus the build descriptions and muddle Makefiles (so
the recipient hopefully has enough context to ``muddle deploy`` if necessary).

For this purpose, the standard distribution "_binary_release" is provided.
The command::

  $ muddle distribute _binary_release ../release_1.0-bin

performs a binary release. It copies:

* the ``install/<role>`` directory for each package (this is, of course,
  the same directory for all packages in the same role)
* the build description (i.e., its checkout) for the top-level and for any
  subdomains that have distributed packages (and any "intermediate" subdomains
  - i.e., if we distribute ``package:(a(b))name/*`` then we will distribute
  the build description for subdomain "a(b)", but also for "a").
* the necessary parts of the ``.muddle`` directory:

  * the ``Description``,  ``RootRepository`` and ``VersionsRepository`` files
  * the ``tags/package`` directory, and the tags for each package and its role
    therein
  * the ``tags/checkout`` directory and the tags for the checkouts used by the
    distributed packages

* the muddle Makefile (alone in its source checkout directory) for each
  package.
 
  For instance, if ``package:zlib{x86}/*`` is built from
  ``checkout:zlib-3.0/checked_out``, using muddle Makefile ``Makefile.muddle``
  in ``src/libs/zlib-3.0``, then the user will receive a directory called
  ``src/libs/zlib-3.0`` that just contains ``Makefile.muddle``.

  Note that this is *not* always enough to allow deployment, and sometimes
  other support files will need to be (epxlicitly) added via the build
  description.

As you might guess, if the ``-with-version`` switch is given, then it will
also distribute the ``versions`` directory, if it exists.

Also, if ``-with-vcs`` is specified, the VCS "special" files for the build
descriptions and the ``versions`` directory (if distributed) will also be
included.

Basic setting up of Licenses
============================
Any piece of source code has a license, whether implicit or explicit.
Muddle does not try to capture the whole essence of what a "license" means,
but simply allows the associate of a checkout with a license name and some
basic properties.

Stuff to do with licensing is conveniently packaged in the
``muddled.licenses`` module, so one might typically do::

  from muddled.licenses import set_license

(and so on for any other items needed from it), or just::

  import muddled.licenses

or::

  import muddled.licenses as licenses

The muddle documentation command can be used to get docstrings from the source
code::

  muddle doc licenses
  muddle doc licenses.LicenseLGPL
  muddle doc licenses.set_license

License categories
------------------
For this purpose, licenses come in four broad categories:

*gpl*

  This category includes all of the FSF GPL licenses.

  For our purposes, they are distinguished by two properties:

  1. There is a requirement to be able to produce the source code on request.
     That "source code" includes the checkout itself and also the build
     infrastructure needed to build it (although there is no requirement that
     this must necessarily work outside the build-as-a-whole).

  2. Some (but not all) GPL licenses "propagate" to other checkouts.

     This means that if package:A is built from GPL checkout:A, and package:B
     links with package:A, then checkout:B may also need to be distributed.

     There are two considerations here, though:

     a. Some GPL-licensed checkouts will have GPL licenses with exemptions
        that specifically allow certain sorts of linking, without causing
        this GPL "propagation". The best know examples are probably the C
        libraries, which one may explicitly link against, and whose header
        files can be freely included, and LGPL licensed sources, against which
        one may freely link *dynamically* (but not statically), and again,
        whose header files can be included.

        To allow for this, when defining a GPL license, muddle allows the
        license to be marked with or without such excemption.

      b. When muddle is told that package:B depends on package:A, there may be
         several reasons for this, not all of which trigger GPL "propagation.
         (Perhaps it depends on a file having been created by package:A, and
         that file itself is not GPL).

         A function is thus provided to allow a build description to say that
         this is in fact the case.

      In either case, not that muddle is not trying to describe the fine
      details of how GPL licenses work, and nor is the above meant to be an
      authoratitive explanation. It is still up to the individual writing the
      build description to use the facilities available to do what is required
      by law.

* *open*

  This category inclused all open-source licenses which are not GPL-like - i.e,,
  they do not *require* source code distribution, nor do they propagate.

* *binary*

  This category is used for checkouts (and thus packages using them) that are
  only to be distributed as binary.
 
  Note that this will still (normally) distribute the appropriate muddle
  Makefile, and possibly other user-nominated files.

* *private*

  This category is used for checkouts (and thus packages using them) that
  should not, in general, be distributed. Some provision is also made for
  not distributing the build description for such packages, as well.

There is also a "meta" type, *not licensed*. Any checkout that has not had its
license specified is regarded as not licensed. In many cases, such checkouts
will be treated as if they had "open" licenses.

Standard licenses
-----------------
Muddle predefines some of the more common licenses, and gives them useful
short names (such as "gpl3", "bsd-new" and "mpl"). A list of the standard
licenses can be printed out with::

  $ muddle query licenses

Licensing a checkout
--------------------
There are several ways to assign a license to a checkout.

The first and simplest is directly::

  set_license(builder, co_label, license)

In this call, ``license`` is either the short name for a standard license, or
an instance of a License subclass (see `Creating a new license`_ below).

``co_label`` is the label for the checkout to which this license should apply.

It may be simpler to specify a license for more than one checkout at the same
time. For this, you can use::

  set_license_for_names(builder, co_names, license)

``license`` is the same as before, but ``co_names`` is a sequence of checkout
*names*. This is normally all that's needed in a build description, but note
that it does mean that the checkouts cannot be in a different domain.

So, for instance::

  set_license(builder, checkout('zlib'), 'zlib')

  set_license_for_names(builder, ['docs', 'specs'],
                        LicenseOpen('Creative Commons Attribution 2.0'
                                    ' UK: England & Wales License.')

Creating a new license
----------------------
There are license classes corresponding to each of the license categories.
They are all subclasses of ``License``, but ``License`` itself is not intended
to be used directly.

* ``LicenseGPL(name, with_exception=False)``

  This creates a GPL license. If ``with_exception`` is True, then the license
  does not automatically "propagate" to other packages/checkouts that depend
  on it.

* ``LicenseLGPL(name, with_exception=False)``

  This creates an LGPL license. If ``with_exception`` is True, then the license
  does not automatically "propagate" to other packages/checkouts that depend
  on it.

  The default, however, is still False because muddle cannot tell whether
  "depends on" means linking to dynamically (which would be OK), statically
  (which would cause "propagation"), or not at all (which would also be OK).

* ``LicenseOpen(name)``
* ``LicenseBinary(name)``
* ``LicensePrivate(name)``

All ``License`` subclass instances have the following values and methods:

* ``category`` is a string containing the category, one of "gpl",
  "open", "binary" or "private".
* ``is_gpl()`` returns True if this is license has category "gpl".
* ``is_lgpl()`` returns True if this license has category "gpl" and is LGPL.
  This is true for the ``LicenseLGPL`` class.
* ``is_open()`` returns True if this license has category "open" or "gpl".
* ``is_open_not_gpl()`` returns True if this license has category "open" (but
  not if it has category "gpl")
* ``is_binary()`` returns True if this license has category "binary"
* ``is_private()`` returns True if this license has category "private"
* ``propagates()`` returns True if the license "propagates" to other
  checkouts. This will be True for licenses in category "gpl" which have
  ``with_exception`` set to False.

So, for instance::

  top_secret = LicensePrivate('Top Secret')
  only_works_on_my_machine = LicensePrivate('Local')
  CC-ASA = LicenseOpen('Creative Commons Attribution-ShareAlike 3.0'
                       ' Unported License')

Note that ``str`` of a License give back the license name::

  >>> str(top_secret)
  'Top Secret'

whilst ``repr`` will give back how to create it::

  >>> repr(top_secret)
  "LicensePrivate('Top Secret')"

The other standard distributions
================================
We've already met the standard distributions that do not take account of
checkout licenses, "_source_release" and "_binary_release". There are also
some standard distributions to help with common cases where licenses should be
observed. These are:

* "_for_gpl"
* "_all_open"
* "_by_license"

.. note:: None of these distribute "private" licensed checkouts. This
   means that if there are such checkouts in the build tree, and the build
  description is meant to *work* when distributed, then some case must be
  taken in its construction - see `Keeping parts of the build description
  private`_ below.

GPL source distribution
-----------------------
The command::

  $ muddle distribute _for_gpl ../gpl_release_1.0

is meant to help with creating a GPL-compliant source code release.

It distributes

* all checkouts that have a GPL license (i.e., one in category GPL)
* all checkouts to which a GPL license has "propagated" (and which have not
  explicitly said they are not affected - see `Avoiding unnecessary GPL
  "propagation"`_ below)
* any necessary build descriptions

It will fail if GPL "propagation" affects checkouts that have declared
"binary" or "private" licenses.

Open source distribution
------------------------
The command::

  $ muddle distribute _all_open ../open_release_1.0

is meant to help with creating a release of all the open-source checkouts in a
build tree. As such, it distributes everything that "_for_gpl" does, plus any
checkouts that have licenses in the "open" category.

Since it includes the "_for_gpl" distribution, it will also fail if GPL
"propagation" affects checkouts that have declared "binary" or "private"
licenses.

By license source/binary distribution
-------------------------------------
The command::

  $ muddle distribute _by_license ../mixed_release_1.0

attempts to distribute as much of the build tree as it can in a
license-appropriate manner. Thus it attempts to distribute:

* source code for "gpl" and "open" licensed checkouts
* binaries for "binary" licensed checkouts
* nothing at all for "private" licensed checkouts

It starts by including the source code content of an "_all_open" distribution
(and can fail for the same reason).

For checkouts with a "binary" license, it determines which packages are built
(directly) from them, and then which role those packages are in. It then
distributes the entirety of the ``install/<role>`` directory for each such
role.

  (See `Not distributing too many binaries`_ below for how to write a build
  description that does not distribute binaries you were not expecting.)

Avoiding unnecessary GPL "propagation"
--------------------------------------
As we've said, muddle has to assume that "depends on" means "links to" (or the
equivalent) when calculating GPL "propagation". Since this is not always so,
we need a way of telling muddle when it is not. This is done with::

  set_not_built_against(builder, pkg_label, co_label)

This says that the package with label ``pkg_label``, which depends (perhaps
indirectly) on the checkout with label ``co_label``, does *not* need to be
distributed because of GPL "propagation" from ``co_label``.

So, for instance, we might have::

  muddled.pkgs.make.medium(builder, 'libProp', ['x86'], 'libProp-2.3')
  muddled.pkgs.make.medium(builder, 'program', ['x86'], 'program-4.9',
                           deps=['libProp'])

  set_license(builder, 'libProp-2.3', 'lgpl')
  set_license(builder, 'program-4.9', 'top-secret')

  # 'program' links dynamically to 'libProp', and thus doesn't need
  # to be distributed as source
  set_not_built_against(builder, package('program', 'x86'), checkout('libProp-2.3'))

| XXX Is lgpl propagation handled correctly by the current code base? Do I have
| XXX a specific test for that? I should have...

Note that this function does not check that:

* ``pkg_label`` actually depends on ``co_label``
* ``co_label`` is GPL licensed
* ``co_label`` is GPL licensed with ``with_exception`` set to False (i.e.,
  that it is a "propagating" license)

but none of these will hurt if incorrect.

Adding extra files
------------------




Keeping parts of the build description private
----------------------------------------------



Not distributing too many binaries
----------------------------------


.. note:: It is arguable that a role that contains binaries from "binary" and
   "open" or "gpl" checkouts should be regarded as a clash in the same way
   that "binary" and "secret" is. This may be implemented in a future version
   of muddle.


Creating your own distributions
===============================




More license stuff -- PUT THIS AT THE END
------------------
A tuple containing all of the license categories is provided::

  ALL_LICENSE_CATEGORIES

You can find out the license for a particular checkout using::

  get_license(builder, co_label)

By default this returns None if the checkout does not have a license, however
you can change that to raising a ``GiveUp`` exception by calling it as::

  get_license(builder, co_label, absent_is_None=True)


set_not_built_against(builder, pkg_label, co_label)

get_not_licensed_checkouts(builder)
get_gpl_checkouts(builder)
get_implicit_gpl_checkouts(builder)
get_open_checkouts(builder)
get_open_not_gpl_checkouts(builder)
get_binary_checkouts(builder)
get_private_checkouts(builder)

checkout_license_allowed(builder, co_label, categories)

licenses_in_role(builder, role)

get_license_clashes(builder, implicit_gpl_checkouts)
get_license_clashes_in_role(builder, role)

report_license_clashes(builder, report_binary=True, report_private=True)
report_license_clashes_in_role(builder, role, just_report_private=True)



.. note:: Some of these functions are useful wrappers around calls of
   ``builder.invocation.db`` methods. Specifically:

   * ``set_license`` is a wrapper for ``builder.invocation.db.set_checkout_license``
   * ``get_license`` is a wrapper for ``builder.invocation.db.get_checkout_license``
     (but beware that the latter swaps the default for ``absent_is_None``, so
     that it defaults to raising an exception if there is no license)
   * ``set_not_built_against`` is a wrapper for ``builder.invocation.db.set_not_built_against``

   There is also a boolean query::

     builder.invocation.db.checkout_has_license(co_label)

   which doesn't currently have a wrapper function.




$ muddle query licenses
$ muddle query checkout-licenses
$ muddle query role-licenses

Working with distributions
==========================

import muddled.distribute

name_distribution(builder, name, categories=None)

.. note:: When listing the categories that a distribution uses, 'gpl' and
   'open' are distinct and separate - there is no assumption that 'open'
   includes 'gpl'. In this instance 'open' means "open but not GPL".

get_distribution_names(builder)
get_distribution_names_for(builder, categories)
get_distribution_names_not_for(builder, categories)
get_used_distribution_names(builder)

  for name in get_distributions_for(['gpl', 'open']):
      distribute_checkout_files(builder, name, co_label, 'Makefile')

  for name in get_distributions_not_for(['private']):
      set_private_build_files(builder, name, ['private_app.py'])

distribute_checkout(builder, name, label, copy_vcs=False)
distribute_package(builder, name, label, obj=False, install=False,
                   with_muddle_makefile=False)

distribute_checkout_files(builder, name, label, source_files)
set_private_build_files(builder, name, private_files)

((distribute_build_desc))

"muddle query distributions" - calls "distribute" function


Caveat on distributing packages and the "install/<role>" directory, and the
fact "muddle distribute" has no way of knowing who put what in there. On
segregating things by role, as necessary, and "muddle query role-licenses".

How to handle "private" stuff.


It is possible to define a distribution within the muddle build description.

Name a distribution
-------------------
::

  name_distribution(builder, name)

Before you can use a distribution, it must be "named". Essentially, the name
of a distribution must be declared before it is used. It is not an error to
name a distribution more than once.

The standard distributions (those whose names start with an underscore) will
already have been named before the build description is read.

.. note:: *Before* in this sense means "in time", so if a subdomain is
   included, and names distribution "Fred", and then the parent domain
   refers to domain "Fred" after the subdomain inclusion, then that will
   work. Of course, it will not be very friendly, as the user is unlikely
   to realise what is going on, so we strongly recommend naming a distribution
   within each build description using it!

Distribution names and wildcards
--------------------------------
The functions that add checkouts, packages and checkout files to distributions
can all take a shell-style wildcard instead of a specific distribution name.
They will then add the relevant entity to all distributions with names that
match that wildcard.

Only distributions that have already been named will be considered in
"expanding" the wildcard.

Wildcarding is done with ``fnmatchcase`` from the Python ``fnmatch`` module,
so::

            *       matches everything
            ?       matches any single character
            [seq]   matches any character in seq
            [!seq]  matches any char not in seq

Distribute a checkout
---------------------
::

  distribute_checkout(builder, name, label, copy_vcs=False)

This is used to say that a particular checkout (identified by ``label``) is to
be part of the distribution called ``name``. If ``name`` is wildcarded (see
`Distribution names and wildcards`_, then the checkout will be added to each
distribution that matches the wildcard.

If ``copy_vcs`` is true, then the checkouts VCS "special" files should be
distributed.

Note that:

a. the label name may also be a wildcard ('*'), in which case all matching
   checkouts will be distributed.
b. the label tag is ignored.

The function creates a rule saying that ``checkout:<name>/distributed`` is
build from ``checkout:<name>/checked_out`` using the DistributeCheckout action.

Adding a checkout to the same distribution more than once has no special
effect, except that it is the last call that sets the value of ``copy_vcs``
that will be used.

.. note:: All checkouts in the build description are implicitly part of
   distribution ``_source_release``. The ``muddle distribute`` command itself
   calls ``distribute_checkout`` to add them to this distribution, after the
   build description has been read. Thus there is never any point in
   explicitly adding a checkout to ``_source_release`` in the build
   description itself, as that will be ignored.

Distribute specific files from a checkout
-----------------------------------------
::

  distribute_checkout_files(builder, name, label, source_files)

This is used to say that the files in sequence ``source_files``, named
relative to the source directory of checkout ``label``, should be distributed
as part of distribution ``name``.

If ``name`` is wildcarded (see `Distribution names and wildcards`_, then the
files will be added to each distribution that matches the wildcard.

Note that the label name may *not* be wildcarded, but the label tag is
ignored.

This is the function that is used internally to add muddle Makefiles for
packages. It can also be used directly to specify that other files must also
be distributed.

Multiple calls with the same ``builder, ``name`` and ``label`` will just add
the specified files to the same distribution.

Calling ``distribute_checkout_files`` after calling ``distribute_checkout``
for the same distribution and checkout has no effect - the latter call has
already selected all files.

Calling ``distribute_checkout`` after calling ``distribute_checkout_files``
for the same distribution and checkout means that the calls of the latter are
essentially ignored, for the same reason (``distribute_checkout`` is choosing
all files).

Build descriptions
------------------
Build description checkouts are treated specially.

The ``muddle distribute`` command adds the necessary rules itself, by calling
``distribute_build_description``, saying that each
``checkout:<build-desc>/distributed`` is built from
``checkout:<build-desc>/checked_out`` using the DistributeBuildDescription
action (which is actually very similar to the DistributeCheckout action, of
course).

There's never any reason to call ``distribute_build_description`` directly,
as ``muddle distribute`` will always override it.

If you do call ``distribute_checkout()`` on a build description checkout, the
rule you add will actually be replaced by ``muddle distribute``.

Distribute a package
--------------------
::

  distribute_package(builder, name, label, obj=False, install=True,
                     with_muddle_makefile=True)


This is used to say that a particular package (identified by ``label``) is to
be part of the distribution called ``name``. If ``name`` is wildcarded (see
`Distribution names and wildcards`_, then the package will be added to each
distribution that matches the wildcard.

Note that:

a. the label name and role may also be wildcards ('*'), in which case all
   matching packages will be distributed.
b. the label tag is ignored.

If ``obj`` is true, then the ``obj/<package-name>/<role>`` directory for
``label`` will be distributed.

If ``install`` is true, then the ``install/<role>`` directory for
``label`` will be distributed.

If ``with_muddle_makefile`` is true, then the muddle Makefile for this
package will also be distributed.
 
For instance, if ``package:zlib{x86}/*`` is built from
``checkout:zlib-3.0/checked_out``, using muddle Makefile ``Makefile.muddle``
in ``src/libs/zlib-3.0``, then the user will receive a directory called
``src/libs/zlib-3.0`` that just contains ``Makefile.muddle``.

Note that this is *not* always enough to allow deployment, and sometimes other
support files will need to be (epxlicitly) added via the build description.

If both ``obj`` and ``install`` are false, nothing much is going to be done
for this package. The current implementation doesn't grumble about that.

The function creates a rule saying that`
`package:<name>{<role>)/distributed`` is built from
``package:<name>{<role>}/postinstalled`` using the DistributePackage action.

Adding a package to the same distribution more than once has no special
effect, except that it is the last call that sets the value of ``obj``,
``install`` and ``with_muddle_makefile`` that will be used for that
distribution.

.. note:: All packages in the build description are implicitly part of
   distribution ``_binary_release``. The ``muddle distribute`` command itself
   calls ``distribute_package`` to add them to this distribution, after the
   build description has been read. Thus there is never any point in
   explicitly adding a package to ``_binary_release`` in the build
   description itself, as that will be ignored.


Still to consider
-----------------
* Can the function calls be made more concise.
* what is meant to happen if contradictory rules are made for a checkout,
  one via ``distribute_checkout()`` and another via ``distribute_package(...,
  source=True)``?

* Should we worry about attempts to (re)build in a binary distributon?

  ::

    $ m3 distrebuild package:main_pkg{x86}
    Building: package:main_pkg{x86}/distclean .. 
    > Building package:main_pkg{x86}/distclean[T]
    Can't build package:main_pkg{x86}/distclean: Missing source directory
      package:main_pkg{x86}/distclean[T] depends on checkout:main_co/*
      Directory /home/tibs/sw/m3/tests/transient/binary/src/main_co does not exist

  And that's OK. Unfortunately, though::

    $ m3 rebuild main_pkg
    Killing package:main_pkg{x86}/built
    Clearing tags for package:main_pkg{x86}/built
      package:main_pkg{x86}/built
      package:main_pkg{x86}/installed
      package:main_pkg{x86}/postinstalled
    Building package:main_pkg{x86}/postinstalled
    > Building package:main_pkg{x86}/built
    Can't build package:main_pkg{x86}/postinstalled - Missing source directory
      package:main_pkg{x86}/built depends on checkout:main_co/*
      Directory /home/tibs/sw/m3/tests/transient/binary/src/main_co does not exist

  so we've now lost our tags. Oh well. At least it told us.

Related commands
================
* ``muddle help distribute`` gives the help text for ``muddle distribute``,
  which summarises some of the above.

* ``muddle query distributions`` lists the names of the distributions that
  exist, either because they are defined in the build description, or because
  they are predefined.

* ``muddle query localroot <label>`` was provided for development purposes in
  this project - it reports on the "local root" for a label, which for a label
  containing a subdomain name will be the "root" of the subdomain.

Deployments
===========
We deliberately do not address distribution of the ``deploy`` directory.

Deployments are already their own distribution mechanism - if a user wants to
distribute some or all of a deployment, then this has normally been addressed
outside the build tree. Also, just copying the ``deploy`` directory (with
``cp`` or ``tar`` or whatever) is a perfectly appropriate thing to do.

(muddle strongly encourages creation of the ``deploy`` directory content in a
way that means it does not have trailing dependencies back into the rest of
the build tree.)

Licenses
========
.. note:: This is work in progress.

We want to be able to say what licence applies to a checkout, so that we can
choose what to distribute by its license. The following thoughts occur:

1. We might only want a single license for a piece of source code, but
   in practice some are multi-licensed, and thus we really should support
   multiple licenses per checkout (if only to make the user happy).

    RESOLVED: No, just the one license we're working to in this build
    description

2. There are three types of license (broadly):

   * Open. These can be freely distributed as source.
   * Closed. These can only be distributed as binary.
   * Private. These must not be distributed at all, and may also need a
     mechanism to prevent distributing the relevant part of the build
     description as well.

   RESOLVED: open is split into GPL and (other) open

3. There's a suggestion that we should be able to attach a license to a
   package as well. Whilst it might be useful to specify an overall license
   for a package, I think this should be seen as really being a license for
   the checkouts used by the package. Reasons for this include:

   * I don't think different licenses for differend roles make sense
   * our "unit of distribution" for source code is the checkout

   RESOLVED: licenses belong to checkouts, but can be specified via a package
   label, much as one can "checkout" a muddle package on the command line

I do not propose that muddle should help with the "contamination" problem.
That is, if a package contains components that are statically linked against a
GPL component, then that package must also be GPL. Trying to work this out
would be a non-trivial problem involving inspection of Makefiles and other
such complicated stuff. It's better to leave it up to humans to work out - and
they need to do so anyway.

Next iteration
--------------
Richard would like active licenses.

So declaring a checkout (or package) as having a particular license adds it to
the distribution of the same name. For "propagating" licenses like LGPL and
GPL, we also want a mechanism for saying that another checkout must also be
released as source, because it depends on that library. In which case we
*also* want a way to say "but actually, even though we 'depend' on it, that
doesn't mean we're linking to it in a GPL-relevant manner, so the license does
not propagate to this checkout".

Most open source licenses (?) don't actually *require* source code
distribution, it's just the GPL related licenses (of course, this needs
checking).

All of this still needs some thought...

...more thought...

So, specifically looking at GPL stuff.

* There is an exemption for system libraries. So when we mark a system library
  as GPL, we may also want to mark it as EXEMPT (if that is so, of course!),
  and then we're specifically free to link against it willy-nilly. An example
  is libgcc.

* If a program is GPL then it can propagate GPL-ness to things it depends on
  if it builds against them. So we may need a way of saying "yes, I depend on
  that, but no I don't propagate license to it".

* If a library is GPL and is depended upon, and the thing depending on it is
  building against it (using header files, inheriting from it, linking againt
  it) then propagation happens. But if we just depend on it being built for
  some other reasons (not sure what), then we also need a mechanism to say
  that we depend upn the library, but do not "use" it.

* If a library is LGPL, then we're explicitly allowed to link to it in a
  shared/dynamic manner. But muddle can't tell this, so we need the same
  mechanism as for a GPL library.

* Bison is special, since it incorporates chunks of itself into its output,
  and that is explicitly allowed for.

So, we need some propagation control mechanisms:

1. If we depend on a GPL entity, or an LGPL entity, then it is assumed that we
   need to distribute our source code unless we declare that we are not doing
   "the thing that requires that".

   So we need an annotation on a checkout that says "I depend on GPL entity X,
   but not in a way that means I need my source distributing".

2. If a GPL entity depends on other checkouts, then we may need to distribute
   the source of those other checkouts.

   So we need an annotation on a checkout saying "I'm GPL, and depend on X,
   but not in a way that means X needs source distributing".

None of which, of course, stop us distributing the source code anyway, if we
want to.

Do other licenses have equivalent requirements?

Some licenses
-------------
From http://opensource.org/licenses/category, with "uninteresting" ones
removed:

* License that are popular and widely used or with strong communities

  - Apache License, 2.0 (Apache-2.0)
  - BSD 3-Clause "New" or "Revised" license (BSD-3-Clause)
  - BSD 3-Clause "Simplified" or "FreeBSD" license (BSD-2-Clause)
  - GNU General Public License (GPL)
  - GNU Library or "Lesser" General Public License (LGPL)
  - MIT license (MIT)
  - Mozilla Public License 2.0 (MPL-2.0)
  - Common Development and Distribution License (CDDL-1.0)
  - Eclipse Public License (EPL-1.0)

* Other/Miscellaneous licenses

  - Adaptive Public License (APL-1.0)
  - Artistic license 2.0 (Artistic-2.0)
  - Open Software License (OSL-3.0)
  - Q Public License (QPL-1.0)
  - zlib/libpng license (Zlib)

* Licenses that are redundant with more popular licenses

  - Academic Free License (AFL-3.0)
  - Attribution Assurance Licenses (AAL)
  - The PostgreSQL License (PostgreSQL)

* Superseded licenses

  - Apache Software License 1.1
  - Common Public License 1.0
  - Artistic license 1.0
  - Mozilla Public License 1.1 (MPL 1.1)
  - Mozilla Public License 1.0 (MPL 1.0)

* Uncategorized Licenses

  - Boost Software License (BSL1.0)

Then there's the UK Open Government License (RAW, not a problem), and perhaps
the Python license (again, not a problem, I think).

Which/where is "BSD with advertising"?

Licenses and distributions
==========================
Brief notes, to be expanded:

Licenses are of four broad types:

* *private*. Checkouts with this license (and thus also their packages) are not
  to be distributed as part of a normal license-driven distribution.

* *binary*. Checkouts with this license (and thus also their packages) are to
  be distributed as binary, not as source. Note that this still distributes
  their muddle Makefile, and any other specific files, as for a "binary"
  release.

* *open*. Checkouts with this license are open-source, but do not *require*
  distribution of their source code.

* *gpl*. Checkouts with this license are open-source, but (a) require
  distribution of their source code, and (b) may or may not propagate that
  requirement to other checkouts whose packages depend on them.

  All *gpl* licenses may have the "with exception" flag set, which implies a
  "linking" exception that stops them "propagating". Otherwise, any checkout
  that depends (whose package depends) on a *gpl* package is a candidate for
  also needing to be distributed as source, unless it is marked (with:

There is also a "meta" type, *not licensed*. Any checkout that has not
had its license declared is *not licensed*, and all such checkouts are assumed to
be equivalent to *open* checkouts. 

We have:

* Various classes, all based off ``License`` (use the subclasses by
  preference, to get their individual behaviours).

* A dictionary of ``standard_licenses``

* Tell a checkout its license::

    set_license(builder, co_label, license)

  where ``license`` is a key from ``standard_licenses`` or a ``License``
  instance.

* Useful query functions::

    get_not_licensed_checkouts(builder)
    get_gpl_checkouts(builder)
    get_implicit_gpl_checkouts(builder)
    check_for_license_clashes(builder, implicit_gpl_checkouts)

  obviously mainly aimed at the muddle developer. See their docstrings for how
  to use them.

* You can find out if a checkout has a license using::

    builder.invocation.db.checkout_has_license(co_label)

  and retrieve a checkout's license wth::

    builder.invocation.db.get_checkout_license(co_label)

  If you think it might not have a license, and don't want a ``GiveUp``
  exception, use::

    builder.invocation.db.get_checkout_license(co_label, absent_is_None=True)

  which returns ``None`` if ``co_label`` does not have a license.

  Setting a license is done with::

    builder.invocation.db.set_checkout_license(co_label, license)

  where ``license`` is either a ``License`` instance, or the name (key) of one
  of the standard licenses.

* Checkouts with GPL-style licenses "propagate" their license to checkouts
  whose packages depend upon them (unless the GPL-style license has
  ``with_exception`` set). This doesn't, however, take account of the fact
  that "depends upon" doesn't necessarily mean "links with" (or "uses header
  files from"). You can tell muddle that a checkout does not need to be
  "propagated to" by a GPL checkout using::

    builder.invocation.db.set_not_built_against(pkg_label, co_label)

  This says that the package named by ``pkg_label`` may depend on the checkout
  named by ``co_label``, but it doesn't do so in a way to trigger GPL
  propagation. Exactly what that means depends upon the package and checkout
  concerned (it may mean not statically linking to an LGPL library, it may
  mean not using classes from a GPL Java class, it may mean depending on a
  side-effect of building the checkout, that itself is not the business of GPL
  licensing).

  Note that if A depends on B depends on C which depends on a GPL checkout D,
  saying that B is "not built against" D doesn't say anything about A or C.

  Also, this call does not check that ``co_label`` has a GPL-style license,
  not least because it may be called before code defining the license for
  ``co_label`` has itself been called. Indeed, we also don't check that
  ``pkg_label`` actually depends on ``co_label``, or that either exists...

* Commands:

  - ``muddle query licenses``

    Prints out the standard licenses

  - ``muddle query checkout-licenses``

     Prints the licenses for the checkouts in the dependency tree, and other
     related information it has deduced. This is deliberately verbose, giving
     as much information as possible.


.. vim: set filetype=rst tabstop=8 softtabstop=2 shiftwidth=2 expandtab:
