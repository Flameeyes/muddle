=====================
``muddle distribute``
=====================

The ``muddle distribute`` command is intended to help with the following use
cases:

1. I want to distribute all of my source code as an archive (typically, a
   ``.tgz`` (gzipped TAR file) or ``.zip`` file). How do I extract the
   relevant directories?

2. I want to prepare a binary release for passing to someone.

3. I want to prepare a distribution where some packages are distributed as
   source code, some as binary, and some not at all.

That third case was actually the driving force of the development of muddle
distribution support, as we wanted to be able to produce a build tree
containing source code for any open-source packages, binary blobs for
proprietary packages whose source code is private, and possibly omitting
entirely packages that are "secret".

The desired intent is that, whatever means (1 through 3) is used, the result
should be a functioning muddle build tree. Clearly this might not always be
possible for some of the more extreme values of case 3 (if too much of the
build tree is not distributed because it is "secret"), but even in such cases
it should ideally be possible to write the build description(s) in such a
manner that something useful can be built.

  (For instance, GPL v2 says "For an executable work, complete source code
  means all the source code for all modules it contains, plus any associated
  interface definition files, plus the scripts used to control compilation and
  installation of the executable." (I hope that counts as fair quoting!).
  At the individual checkout/package level, the Makefiles are simple to
  distribute. Quite often the "scripts used to ..." for the entire system,
  though, are indeed those used to build the system, but don't actually
  function outside the original context in which they were used. We'd like to
  make it possible, in this sort of situation, to distribute muddle build
  trees that actually work and produce someting
  useful.)

What is a distribution?
=======================
A distribution is two things:

1. a copy of all or part of the muddle build tree
2. a description of what to copy, for this purpose

The ``muddle distribute`` command uses an instance of (2) to produce (1).

A distribution (in the sense of a set of instructions for distributing) is
identified by a name. This is just a string, and at the moment has no
restrictions on its content. However, as normal, we reserve any names starting
with underscore (``_``) for the system to define (there are currently two
examples), and we recommend sticking to ``A-Za-z0-9_-`` for the characters in
the name. However, that is not enforced.

How does it work?
=================
.. note:: Ignore this little section if you want.

More-or-less as you might expect, with labels and tags and actions.

Basically, for those checkouts or packages that are to be distributed, a rule
is added to "build" label ``checkout:<name>/distributed`` from
``checkout:<name>/checked_out`` using the DistributeCheckout action, or
``package:<name>{<role>)/distributed`` from
``package:<name>{<role>}/postinstalled`` using the DistributePackage action.

.. note:: *Technically* doing a DistributePackage of just the ``obj``
   directories doesn't require that the package(s) be ``/postinstalled``,
   as ``/built`` would suffice. I don't think that's worth worrying about
   at the moment, especially as ``muddle`` always builds through to
   ``/postinstalled`` if at all posible (i.e., that's what ``muddle build``
   does, and see what it says in ``muddle help build`` about depending
   on ``/postinstalled`` being the norm).

For source and binary releases (cases 1 and 2) the ``muddle distribute``
command itself organises this. For case 3, appropriate code in the build
description causes the rules to be added.

You won't, however, see any ``/distribute`` tags in the ``.muddle`` tags
directories, as the ``/distribute`` tag is treated as "transient" - i.e., it
doesn't get recorded on disk. This avoids problems if one (for instance) does
a source distribution with VCS to one directory, and then without to another,
followed by a partial distribution to yet another - it would not be clear what
the ``/distribute`` tags meant, and it would always be necessary to clear them
before each ``muddle distribute``.

Case 1: Source distribution
===========================

.. note:: The use case in this section seem to be fairly well satisfied
   by the current implementation, so is likely to be reasonably stable

In a simple build tree, where there are no subdomains, a `.tgz`` file can be
produced with a command like::

  tar -zcvf archive.tgz build/src build/.muddle build/versions

where ``build`` is the directory containing the build tree.

If VCS directories (``.git/`` and the like) are not wanted, then something
like::

  tar -zcvf --exclude-vcs archive.tgz build/src build/.muddle build/versions

may suffice.

However:

a. Neither of those copies over the ``.muddle`` directory, and if one asked
   to archive the ``.muddle`` directory, one would get all of it, not just
   the parts needed (and one might also get tags set for packages indicating
   that they have been built, which will not be true of the archived build
   tree).
b. If there are subdomains, the command would need to be rather more complex.
   And if you're doing something weird, like having a VCS directory (perhaps
   ``.git``) for the tree as stored in the local repositories, but also a
   historitcal VCS directory (perhaps ``.bzr``) that came with the checkout
   when it was imported, then it all gets rather difficult.

So instead one can do::

  pushd build
  muddle distribute -with-version _source_release ../release_1.0
  popd
  tar -zcvf release_1.0.tgz release_1.0

which will copy the sources to a directory called ``release_1.0``.

Specifically, it will copy:

* each checkout directory, including the build description, in all domains
* the ``versions`` directory, if it exists
* the necessary parts of the ``.muddle`` directory:

  * the ``Description``,  ``RootRepository`` and ``VersionsRepository`` files
  * the ``tags/checkout`` directory and the tags for the copied checkouts

It does not copy VCS "special" files (as determined by the build description,
``.git``, ``.gitignore``, etc.) for the checkouts, or for the ``versions``
directory.

If the ``versions`` directory is not wanted, then the ``-with-versions``
switch can be left off.

If the VCS "special" files in the checkouts (and ``versions`` directory) *are*
wanted, then the ``-with-vcs`` switch should be specified::

  muddle distribute -with-version -with-vcs _source_release ../release_1.0.vcs

In either case, because the necessary parts of the ``.muddle`` directory have
been copied, it should be possible to build the build tree in the normal
manner::

  cd release_1.0
  muddle

Case 2: Binary distribution
===========================

.. note:: Whilst I think this section makes sense, it is possible that it
   may be re-addressed in the future.

Sometimes someone wants a binary release. A binary release is taken to be
the "end product" of doing a ``muddle build``, and is thus the content of the
``install`` directories, plus the build descriptions and muddle Makefiles (so
the recipient hopefully has enough context to ``muddle deploy`` if necessary).

The command::

  muddle distribute _binary_release ../release_1.0-bin

performs a binary release. It copies:

* the ``install/<role>`` directory for each package (this is, of course,
  the same directory for all packages in the same role)
* the build description (i.e., its checkout) for the top-level and for any
  subdomains that have distributed packages (and any "intermediate" subdomains
  - i.e., if we distribute ``package:(a(b))name/*`` then we will distribute
  the build description for subdomain "a(b)", but also for "a").
* the necessary parts of the ``.muddle`` directory:

  * the ``Description``,  ``RootRepository`` and ``VersionsRepository`` files
  * the ``tags/package`` directory, and the tags for each package and its role
    therein
  * the ``tags/checkout`` directory and the tags for the checkouts used by the
    distributed packages

* the muddle Makefile (alone in its source checkout directory) for each
  package.
 
  For instance, if ``package:zlib{x86}/*`` is built from
  ``checkout:zlib-3.0/checked_out``, using muddle Makefile ``Makefile.muddle``
  in ``src/libs/zlib-3.0``, then the user will receive a directory called
  ``src/libs/zlib-3.0`` that just contains ``Makefile.muddle``.

  Note that this is *not* always enough to allow deployment, and sometimes
  other support files will need to be (epxlicitly) added via the build
  description.

As you might guess, if the ``-with-version`` switch is given, then it will
also distribute the ``versions`` directory, if it exists.

Also, if ``-with-vcs`` is specified, the VCS "special" files for the build
descriptions and the ``versions`` directory (if distributed) will also be
included.

Case 3: Describing a distribution
=================================

.. note:: This section is still evolving, and much work still remains to be
   done on working out what we want to do and how to do it

It is possible to define a distribution within the muddle build description.

Name a distribution
-------------------
::

  name_distribution(builder, name)

Before you can use a distribution, it must be "named". Essentially, the name
of a distribution must be declared before it is used. It is not an error to
name a distribution more than once.

The standard distributions (those whose names start with an underscore) will
already have been named before the build description is read.

.. note:: *Before* in this sense means "in time", so if a subdomain is
   included, and names distribution "Fred", and then the parent domain
   refers to domain "Fred" after the subdomain inclusion, then that will
   work. Of course, it will not be very friendly, as the user is unlikely
   to realise what is going on, so we strongly recommend naming a distribution
   within each build description using it!

Distribution names and wildcards
--------------------------------
The functions that add checkouts, packages and checkout files to distributions
can all take a shell-style wildcard instead of a specific distribution name.
They will then add the relevant entity to all distributions with names that
match that wildcard.

Only distributions that have already been named will be considered in
"expanding" the wildcard.

Wildcarding is done with ``fnmatchcase`` from the Python ``fnmatch`` module,
so::

            *       matches everything
            ?       matches any single character
            [seq]   matches any character in seq
            [!seq]  matches any char not in seq

Distribute a checkout
---------------------
::

  distribute_checkout(builder, name, label, copy_vcs=False)

This is used to say that a particular checkout (identified by ``label``) is to
be part of the distribution called ``name``. If ``name`` is wildcarded (see
`Distribution names and wildcards`_, then the checkout will be added to each
distribution that matches the wildcard.

If ``copy_vcs`` is true, then the checkouts VCS "special" files should be
distributed.

Note that:

a. the label name may also be a wildcard ('*'), in which case all matching
   checkouts will be distributed.
b. the label tag is ignored.

The function creates a rule saying that ``checkout:<name>/distributed`` is
build from ``checkout:<name>/checked_out`` using the DistributeCheckout action.

Adding a checkout to the same distribution more than once has no special
effect, except that it is the last call that sets the value of ``copy_vcs``
that will be used.

.. note:: All checkouts in the build description are implicitly part of
   distribution ``_source_release``. The ``muddle distribute`` command itself
   calls ``distribute_checkout`` to add them to this distribution, after the
   build description has been read. Thus there is never any point in
   explicitly adding a checkout to ``_source_release`` in the build
   description itself, as that will be ignored.

Distribute specific files from a checkout
-----------------------------------------
::

  distribute_checkout_files(builder, name, label, source_files)

This is used to say that the files in sequence ``source_files``, named
relative to the source directory of checkout ``label``, should be distributed
as part of distribution ``name``.

If ``name`` is wildcarded (see `Distribution names and wildcards`_, then the
files will be added to each distribution that matches the wildcard.

Note that the label name may *not* be wildcarded, but the label tag is
ignored.

This is the function that is used internally to add muddle Makefiles for
packages. It can also be used directly to specify that other files must also
be distributed.

Multiple calls with the same ``builder, ``name`` and ``label`` will just add
the specified files to the same distribution.

Calling ``distribute_checkout_files`` after calling ``distribute_checkout``
for the same distribution and checkout has no effect - the latter call has
already selected all files.

Calling ``distribute_checkout`` after calling ``distribute_checkout_files``
for the same distribution and checkout means that the calls of the latter are
essentially ignored, for the same reason (``distribute_checkout`` is choosing
all files).

Build descriptions
------------------
Build description checkouts are treated specially.

The ``muddle distribute`` command adds the necessary rules itself, by calling
``distribute_build_description``, saying that each
``checkout:<build-desc>/distributed`` is built from
``checkout:<build-desc>/checked_out`` using the DistributeBuildDescription
action (which is actually very similar to the DistributeCheckout action, of
course).

There's never any reason to call ``distribute_build_description`` directly,
as ``muddle distribute`` will always override it.

If you do call ``distribute_checkout()`` on a build description checkout, the
rule you add will actually be replaced by ``muddle distribute``.

Distribute a package
--------------------
::

  distribute_package(builder, name, label, obj=False, install=True,
                     with_muddle_makefile=True)


This is used to say that a particular package (identified by ``label``) is to
be part of the distribution called ``name``. If ``name`` is wildcarded (see
`Distribution names and wildcards`_, then the package will be added to each
distribution that matches the wildcard.

Note that:

a. the label name and role may also be wildcards ('*'), in which case all
   matching packages will be distributed.
b. the label tag is ignored.

If ``obj`` is true, then the ``obj/<package-name>/<role>`` directory for
``label`` will be distributed.

If ``install`` is true, then the ``install/<role>`` directory for
``label`` will be distributed.

If ``with_muddle_makefile`` is true, then the muddle Makefile for this
package will also be distributed.
 
For instance, if ``package:zlib{x86}/*`` is built from
``checkout:zlib-3.0/checked_out``, using muddle Makefile ``Makefile.muddle``
in ``src/libs/zlib-3.0``, then the user will receive a directory called
``src/libs/zlib-3.0`` that just contains ``Makefile.muddle``.

Note that this is *not* always enough to allow deployment, and sometimes other
support files will need to be (epxlicitly) added via the build description.

If both ``obj`` and ``install`` are false, nothing much is going to be done
for this package. The current implementation doesn't grumble about that.

The function creates a rule saying that`
`package:<name>{<role>)/distributed`` is built from
``package:<name>{<role>}/postinstalled`` using the DistributePackage action.

Adding a package to the same distribution more than once has no special
effect, except that it is the last call that sets the value of ``obj``,
``install`` and ``with_muddle_makefile`` that will be used for that
distribution.

.. note:: All packages in the build description are implicitly part of
   distribution ``_binary_release``. The ``muddle distribute`` command itself
   calls ``distribute_package`` to add them to this distribution, after the
   build description has been read. Thus there is never any point in
   explicitly adding a package to ``_binary_release`` in the build
   description itself, as that will be ignored.


Still to consider
-----------------
* Can the function calls be made more concise.
* what is meant to happen if contradictory rules are made for a checkout,
  one via ``distribute_checkout()`` and another via ``distribute_package(...,
  source=True)``?

* Should we worry about attempts to (re)build in a binary distributon?

  ::

    $ m3 distrebuild package:main_pkg{x86}
    Building: package:main_pkg{x86}/distclean .. 
    > Building package:main_pkg{x86}/distclean[T]
    Can't build package:main_pkg{x86}/distclean: Missing source directory
      package:main_pkg{x86}/distclean[T] depends on checkout:main_co/*
      Directory /home/tibs/sw/m3/tests/transient/binary/src/main_co does not exist

  And that's OK. Unfortunately, though::

    $ m3 rebuild main_pkg
    Killing package:main_pkg{x86}/built
    Clearing tags for package:main_pkg{x86}/built
      package:main_pkg{x86}/built
      package:main_pkg{x86}/installed
      package:main_pkg{x86}/postinstalled
    Building package:main_pkg{x86}/postinstalled
    > Building package:main_pkg{x86}/built
    Can't build package:main_pkg{x86}/postinstalled - Missing source directory
      package:main_pkg{x86}/built depends on checkout:main_co/*
      Directory /home/tibs/sw/m3/tests/transient/binary/src/main_co does not exist

  so we've now lost our tags. Oh well. At least it told us.

Related commands
================
* ``muddle help distribute`` gives the help text for ``muddle distribute``,
  which summarises some of the above.

* ``muddle query distributions`` lists the names of the distributions that
  exist, either because they are defined in the build description, or because
  they are predefined.

* ``muddle query localroot <label>`` was provided for development purposes in
  this project - it reports on the "local root" for a label, which for a label
  containing a subdomain name will be the "root" of the subdomain.

Deployments
===========
We deliberately do not address distribution of the ``deploy`` directory.

Deployments are already their own distribution mechanism - if a user wants to
distribute some or all of a deployment, then this has normally been addressed
outside the build tree. Also, just copying the ``deploy`` directory (with
``cp`` or ``tar`` or whatever) is a perfectly appropriate thing to do.

(muddle strongly encourages creation of the ``deploy`` directory content in a
way that means it does not have trailing dependencies back into the rest of
the build tree.)

Licenses
========
.. note:: This is work in progress.

We want to be able to say what licence applies to a checkout, so that we can
choose what to distribute by its license. The following thoughts occur:

1. We might only want a single license for a piece of source code, but
   in practice some are multi-licensed, and thus we really should support
   multiple licenses per checkout (if only to make the user happy).

2. There are three types of license (broadly):

   * Open. These can be freely distributed as source.
   * Closed. These can only be distributed as binary.
   * Secret. These must not be distributed at all, and may also need a
     mechanism to prevent distributing the relevant part of the build
     description as well.

3. There's a suggestion that we should be able to attach a license to a
   package as well. Whilst it might be useful to specify an overall license
   for a package, I think this should be seen as really being a license for
   the checkouts used by the package. Reasons for this include:

   * I don't think different licenses for differend roles make sense
   * our "unit of distribution" for source code is the checkout

I do not propose that muddle should help with the "contamination" problem.
That is, if a package contains components that are statically linked against a
GPL component, then that package must also be GPL. Trying to work this out
would be a non-trivial problem involving inspection of Makefiles and other
such complicated stuff. It's better to leave it up to humans to work out - and
they need to do so anyway.

We obviously need ``muddle query licenses`` which lists the checkouts and
their declared license (if any).

Richard suggested it would be nice to have an introspection capability, where
muddle would "guess" the license by looking at the content of the checkout
directory. This feels like it should work for well-formed GPL checkouts
(although if would not, of course, detect dual-licensing).

I think the license "memory" should live in db.py, alongside the other
dictionaries of ``checkout -> xxx`` (i.e., location and repository). This
means the label mangling done at subdomain inclusion time will be handled in a
tidy manner.

Initially we then want ``builder.set_license(...)`` functions - possible two
APIs:

1. ``builder.set_license(name, license1, license2, ...)`` which takes a
   checkout ``name`` (but doesn't cope with domains)

2. ``builder.set_label_licenses(label, [license1, license2, ...])`` which
   takes a package or checkout license, and sets the values in the
   checkout-to-license dictionary.

Eventually we may want all the "useful" functions (``make.twolevel``, etc.)
to support ``license`` (and maybe also ``licenses``???) arguments - but that
can be after we've proven the technology.

Then we want to add another way of describing a distribution::

  distribute_licenses(builder, name, [license1, license2, ...], binary=True,
                      source=True, copy_vcs=False)

Note that this doesn't know anything about what the licenses *mean*. It's
possible we want some checking mechanism that recognises some licenses as open
and some as closed, and grumbles if we do unlikely or disallowed things.

Naming licenses:

* For the common licenses, define simple strings for them::

      GPL2 = 'gpl2'
      MPL1 = 'mpl1.1'
      BSD  = 'BSD'

* For specialised open licenses, prefix them with ``open``::

       open:zlib

* For binary licenses, prefix them with ``binary``::

       binary:customerA

* For secret licenses, perhaps we only need ``secret`` - anything else gives
  away information!

Second iteration
----------------
``License(name, category)``, where ``name`` is the common name for the license,
and ``category`` is one of ``open``, ``binary`` or ``secret``.

Licenses are static things, they're just a way of naming what we've got.

Next iteration
--------------
Richard would like active licenses.

So declaring a checkout (or package) as having a particular license adds it to
the distribution of the same name. For "propagating" licenses like LGPL and
GPL, we also want a mechanism for saying that another checkout must also be
released as source, because it depends on that library. In which case we
*also* want a way to say "but actually, even though we 'depend' on it, that
doesn't mean we're linking to it in a GPL-relevant manner, so the license does
not propagate to this checkout".

Most open source licenses (?) don't actually *require* source code
distribution, it's just the GPL related licenses (of course, this needs
checking).

All of this still needs some thought...

...more thought...

So, specifically looking at GPL stuff.

* There is an exemption for system libraries. So when we mark a system library
  as GPL, we may also want to mark it as EXEMPT (if that is so, of course!),
  and then we're specifically free to link against it willy-nilly. An example
  is libgcc.

* If a program is GPL then it can propagate GPL-ness to things it depends on
  if it builds against them. So we may need a way of saying "yes, I depend on
  that, but no I don't propagate license to it".

* If a library is GPL and is depended upon, and the thing depending on it is
  building against it (using header files, inheriting from it, linking againt
  it) then propagation happens. But if we just depend on it being built for
  some other reasons (not sure what), then we also need a mechanism to say
  that we depend upn the library, but do not "use" it.

* If a library is LGPL, then we're explicitly allowed to link to it in a
  shared/dynamic manner. But muddle can't tell this, so we need the same
  mechanism as for a GPL library.

* Bison is special, since it incorporates chunks of itself into its output,
  and that is explicitly allowed for.

So, we need some propagation control mechanisms:

1. If we depend on a GPL entity, or an LGPL entity, then it is assumed that we
   need to distribute our source code unless we declare that we are not doing
   "the thing that requires that".

   So we need an annotation on a checkout that says "I depend on GPL entity X,
   but not in a way that means I need my source distributing".

2. If a GPL entity depends on other checkouts, then we may need to distribute
   the source of those other checkouts.

   So we need an annotation on a checkout saying "I'm GPL, and depend on X,
   but not in a way that means X needs source distributing".

None of which, of course, stop us distributing the source code anyway, if we
want to.

Do other licenses have equivalent requirements?

Some licenses
-------------
From http://opensource.org/licenses/category, with "uninteresting" ones
removed:

* License that are popular and widely used or with strong communities

  - Apache License, 2.0 (Apache-2.0)
  - BSD 3-Clause "New" or "Revised" license (BSD-3-Clause)
  - BSD 3-Clause "Simplified" or "FreeBSD" license (BSD-2-Clause)
  - GNU General Public License (GPL)
  - GNU Library or "Lesser" General Public License (LGPL)
  - MIT license (MIT)
  - Mozilla Public License 2.0 (MPL-2.0)
  - Common Development and Distribution License (CDDL-1.0)
  - Eclipse Public License (EPL-1.0)

* Other/Miscellaneous licenses

  - Adaptive Public License (APL-1.0)
  - Artistic license 2.0 (Artistic-2.0)
  - Open Software License (OSL-3.0)
  - Q Public License (QPL-1.0)
  - zlib/libpng license (Zlib)

* Licenses that are redundant with more popular licenses

  - Academic Free License (AFL-3.0)
  - Attribution Assurance Licenses (AAL)
  - The PostgreSQL License (PostgreSQL)

* Superseded licenses

  - Apache Software License 1.1
  - Common Public License 1.0
  - Artistic license 1.0
  - Mozilla Public License 1.1 (MPL 1.1)
  - Mozilla Public License 1.0 (MPL 1.0)

* Uncategorized Licenses

  - Boost Software License (BSL1.0)

Then there's the UK Open Government License (RAW, not a problem), and perhaps
the Python license (again, not a problem, I think).

Which/where is "BSD with advertising"?

Licenses and distributions
==========================
Brief notes, to be expanded:

Licenses are of four broad types:

* *secret*. Checkouts with this license (and thus also their packages) are not
  to be distributed as part of a normal license-driven distribution.

* *binary*. Checkouts with this license (and thus also their packages) are to
  be distributed as binary, not as source. Note that this still distributes
  their muddle Makefile, and any other specific files, as for a "binary"
  release.

* *open*. Checkouts with this license are open-source, but do not *require*
  distribution of their source code.

* *gpl*. Checkouts with this license are open-source, but (a) require
  distribution of their source code, and (b) may or may not propagate that
  requirement to other checkouts whose packages depend on them.

  All *gpl* licenses may have the "with exception" flag set, which implies a
  "linking" exception that stops them "propagating". Otherwise, any checkout
  that depends (whose package depends) on a *gpl* package is a candidate for
  also needing to be distributed as source, unless it is marked (with:

There is also a "meta" type, *not licensed*. Any checkout that has not
had its license declared is *not licensed*, and all such checkouts are assumed to
be equivalent to *open* checkouts. 

We have:

* Various classes, all based off ``License`` (use the subclasses by
  preference, to get their individual behaviours).

* A dictionary of ``standard_licenses``

* Tell a checkout its license::

    set_license(builder, co_label, license)

  where ``license`` is a key from ``standard_licenses`` or a ``License``
  instance.

* Useful query functions::

    get_not_licensed_checkouts(builder)
    get_gpl_checkouts(builder)
    get_implicit_gpl_checkouts(builder)
    check_for_license_clashes(builder, implicit_gpl_checkouts)

  obviously mainly aimed at the muddle developer. See their docstrings for how
  to use them.

* You can find out if a checkout has a license using::

    builder.invocation.db.checkout_has_license(co_label)

  and retrieve a checkout's license wth::

    builder.invocation.db.get_checkout_license(co_label)

  If you think it might not have a license, and don't want a ``GiveUp``
  exception, use::

    builder.invocation.db.get_checkout_license(co_label, absent_is_None=True)

  which returns ``None`` if ``co_label`` does not have a license.

  Setting a license is done with::

    builder.invocation.db.set_checkout_license(co_label, license)

  where ``license`` is either a ``License`` instance, or the name (key) of one
  of the standard licenses.

* Checkouts with GPL-style licenses "propagate" their license to checkouts
  whose packages depend upon them (unless the GPL-style license has
  ``with_exception`` set). This doesn't, however, take account of the fact
  that "depends upon" doesn't necessarily mean "links with" (or "uses header
  files from"). You can tell muddle that a checkout does not need to be
  "propagated to" by a GPL checkout using::

    builder.invocation.db.set_not_built_against(pkg_label, co_label)

  This says that the package named by ``pkg_label`` may depend on the checkout
  named by ``co_label``, but it doesn't do so in a way to trigger GPL
  propagation. Exactly what that means depends upon the package and checkout
  concerned (it may mean not statically linking to an LGPL library, it may
  mean not using classes from a GPL Java class, it may mean depending on a
  side-effect of building the checkout, that itself is not the business of GPL
  licensing).

  Note that if A depends on B depends on C which depends on a GPL checkout D,
  saying that B is "not built against" D doesn't say anything about A or C.

  Also, this call does not check that ``co_label`` has a GPL-style license,
  not least because it may be called before code defining the license for
  ``co_label`` has itself been called. Indeed, we also don't check that
  ``pkg_label`` actually depends on ``co_label``, or that either exists...

* Commands:

  - ``muddle query licenses``

    Prints out the standard licenses

  - ``muddle query checkout-licenses``

     Prints the licenses for the checkouts in the dependency tree, and other
     related information it has deduced. This is deliberately verbose, giving
     as much information as possible.

Still to consider
-----------------
If we are distributing a build description, and that build description may
build "secret" things, how do we not distribute any information about the
building of said "secret" things?

Well, the simplest way is probably:

a. Move all the code for building the "secret" things into one or more
   distinct Python scripts (in the build description directory)
b. Have a mechanism to tell the distribution code that, if non-"secret" things
   are not being distributed, then empty files (of the same name) should be
   distributed instead of those files.

So, how do we declare that *in the build description*?

Something like::

  secret_build_files(builder, build_files)

where ``build_files`` is a list of Python files, relative to the build
description directory. For instance::

  secret_build_files(builder, name, ['secret_app.py', 'subdir/other_app.py'])

I propose that this *must* be done within a build description with respect to
itself - i.e., a build description cannot affect a subdomain's build
description (that just gets too complicated).

Questions:

1. Can I think of a better function name(!)
2. Do we require the ``.py`` at the end of the filename(s)?

This appears to only affect the "_by_license" distribution...

  Implementation is by adding a list of such files to the
  ``DistributeBuildDescriptionAction`` for the build description, and
  then making the function that does the work for that do the right thing.

Do we want an equivalent for subdomains as well::

  secret_subdomains(builder, domain_names)

(although I think I'd rather leave that, as we don't have a need for it).



Question:
---------
Should the registry of distribution names have a list of license categories
that it will distribute? So, for instance::

  { '_source_release' : ['gpl', 'open', 'binary', 'secret']
    '_binary_release' : ['gpl', 'open', 'binary', 'secret'],
    '_for_gpl': ['gpl'],
    '_all_open': ['gpl', 'open'],
    '_by_license': ['gpl', 'open', 'binary'],
  }

Note that this is things that will be distributed, not *how*, so
``_binary_release`` distributes anything regardless of license category,
but doesn't distribute sources.

This allows us to tell which distributions will (for instance) distribute
"secret" stuff, and to be more intelligent about clashes.

We presumably then also have to police the adding of checkouts to a
distribution, so that a 'binary' licensed checkout can only be added to a
distribution that allows it.

THEN we can detect if we're doing a "secret" distribution or not, and thus
decide what to do about those pesky secret build description files...

And maybe the "add extra files" function should be by name or by license
category???

Or we could just have a "get" function for existing distribution names, and
the user can then do::

  for name in get_distributions_for(['gpl', 'open']):
      distribute_checkout_files(builder, name, co_label, 'Makefile')

in the build description. Yes, I think that works. And similarly::

  for name in get_distributions_not_for(['secret']):
      set_secret_build_files(builder, name, ['secret_app.py'])

So we name distributions with::

    name_distribution(builder, name, categories=None)

where ``categories`` is a list of license categories, or None to mean all of
them.

So the final question becomes, do we treat "open" as meaning "including gpl"
- i.e., does it make sense to do::

    categories=['gpl', 'open']

or is that actually identical to::

    categories=['open']

because it doesn't make sense to try to choose "open" without choosing "gpl"?

.. vim: set filetype=rst tabstop=8 softtabstop=2 shiftwidth=2 expandtab:
